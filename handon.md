+++
title = "React app example"
#date = "2020-06-12"
weight = 14
+++

React is a JavaScript library, maintained by Facebook and a community of developers, which is used for creating single-page applications.

This tutorial aims to show you how you can use the React framework to create an application, which connects to MQTT to get data coming from sensors. Those sensors have different locations, which we will visualize on a map, including the real time readings from them.


### Requirements

To get started with this tutorial, you need the following things installed:

- Node.js (version 8.11.3 or higher)
- NPM (version 5.6.0 or higher)
- Google maps API key
- MQTT token


### Create React app

As a start, we need to create our React app by using the official Create React App tool. With only one command, this tool will set up our folder structure, files and tools that we need to start working on our React project. Note that we will make use of **npx** (installed together with npm), which is used as replacement for installing **react-create-app** globally. Npx will make sure that we always use the latest version of the tool. Open your terminal window, go to a folder where you want your project to be created and type the following command:

```bash
npx create-react-app react-demo
```

That will create a folder called react-demo where the source code of our new app is located. Your folder structure will look like this:

![](/react-folder-structure.jpg)

In this tutorial we will mainly work with the file called **App.js** , which contains the base of our app. Typically, a React application will consist of multiple components, you can create all of them within App.js, but it's cleaner if you add separate files for each one.

We can directly run our app by using the following two commands:

```bash
cd my-app
npm start
```

When you open **localhost:3000** , you will now see a simple page that is automatically generated by the Create React app tool. We will replace that with our own component in the next steps of this tutorial.


### Creating our Map component

In this step we will create a new Map component, which will render our map.

Let's begin by creating the component and importing it into our **App.js**. Create two files called **Map.js** and **Map.css** in the source folder. **Map.css** will be used later for our styling. **Map.js** is where the JavaScript code for displaying our map will be. Here is what we will begin with:

```javascript
import React from 'react';
import './Map.css';

class Map extends React.Component {
  render() {
    return (
      <div className='Map'></div>
    );
  }
}

export default Map;
```

In the code above you can see that we declare our Map component and export it so that it can be used in our App.js. The only method that we are using for now is the render, where we've added an HTML div element, which will be a container for our map. We give it a className map-container, which is the react equivalent of class. We will use that one later for styling.

For creating our actual map we will use **Leaflet**, a lightweight JavaScript library that makes it easy to display a map and add points of interest on it as markers. Each marker can have a pop-up, containing some text. Leaflet can be installed with the following terminal command inside our react-demo folder:

```bash
npm install leaflet –save-dev
```

After it's installed, we can import it in our **Map.js** with the following lines:

```javascript
import L from 'leaflet';
import 'leaflet/dist/leaflet.css';
```

To render our map, we first create a HTML div element for it in our **render** method:

```javascript
render() {
  return (
    <div className="Map">
      <div id='map' className="map-container" />
    </div>
  );
}
```

To store the coordinates for the center of our map, the zoom level and our actual map, we will make use of React's built-in **state** object. The state object is where you store property values that belong to the component. When the state changes, the component will re-render. In our case we will need the variables **map** , **mapCenter** and **mapZoomLevel** in the state object. Those will be used when we render the map with Leaflet. We will initialize our state in a constructor method inside **Map.js**:

```javascript
constructor() {
  super();

  this.state = {
    map: null,
    mapCenter: [52.370216, 4.895168],
    mapZoomLevel: 11
  }
}
```
| variable | description |
| --- | --- |
| map | used to store our map so that we can later refer to it when we want to add markers on the map |
| mapCenter | contains the coordinates of the center of our map |
| mapZoomLevel | Contains the zoom level of the map |

Now we are ready to render our map. To do that we will write a new function for it, called **renderMap**:

```javascript
renderMap() {
  const map = L.map('map').setView(this.state.mapCenter, this.state.mapZoomLevel)
  L.tileLayer('http://{s}.google.com/vt/lyrs=m,m&x={x}&y={y}&z={z}',{
    apiKey: 'insert your api key here',
    subdomains:['mt0','mt1','mt2','mt3'],
    preferCanvas: true
  }).addTo(map);

  this.setState({
    map
  });
}
```

This function will create a map and render it in the div that we added earlier. Since we are using Google Maps you will need to get your own Google maps API key and replace that inside the code.

After rendering the map, we will update our state with the newly created map const. This is done by making use of React's **setState** method. Then we are ready to call our **renderMap** function inside our **componentDidMount** method. ComponentDidMount is a method that React calls after all the elements of the page are rendered correctly. This is important because for our map to be added, the div element with id map must be present on the page. Here is what our componentDidMount function should look like:

```javascript
componentDidMount() {
  this.renderMap();
}
```

The last step before we can see our map is to import our Map component inside our **App.js**:

```javascript
import Map from './Map';
```

And add the Map inside the **render** method:

```javascript
render() {
  return (
    <div className="App">
      <Map></Map>
    </div>
  );
}
```


### Styling

As for the styling of out map, we will keep things simple in this tutorial. The only thing that we will do is make the map as big as our browser window. The HTML of our Map component is wrapped in a div element, which by default has the class Map. For this one we will add the following css inside the **Map.css** file that we created earlier:

```css
.Map {
  width: 100vw;
  height: 100vh;
}
```

This will let our Map component take up the full width and height of our browser window.

As a next step, we will style the div, which Leaflet uses as a container for rendering the map. We gave this one a class map-container. Here is the css that we will use for that one:

```css
.map-container {
  width: 100%;
  height: 100%;
}
```


### MQTT connection

At this point we have our map, it's time to create a MQTT connection. This connection will let us get data from the DSH. Here is a diagram that visualizes this process:

![](/dsh-kafkastreams.svg)

To establish a MQTT connection, we will make use of the **async-mqtt** library. It is installed with the following command:

```bash
npm install async-mqtt –-save-dev
```

For making our connection, we will need to use a token, which has to be decoded using the **jsonwebtoken** library. It can be installed by running:

```bash
npm install jsonwebtoken –-save-dev
```

We should first import the **async-mqtt** and **jsonwebtoken** libraries to our **Map.js** file.

```javascript
import mqtt from 'async-mqtt';
import jwt from 'jsonwebtoken';
```

Then we want to create two constants that will store our MQTT token and the topic, which we will be subscribing to. We will be using those when we create our connection and subscribe to the topic later.

```javascript
const token = "your token";
const airpollutionTopic = `/tt/airpollution/1/2/0/2/0/2/1/1/0/1/1/3/#`;
```

In the above code you need to replace the token with your own. Information on how you can request a token is discussed in the Tenant in One Day training, in the chapter about MQTT. You can find some information here: [https://dshdoc.poc.kpn-dsh.com/tutorial/mqtt/](https://dshdoc.poc.kpn-dsh.com/tutorial/mqtt/). This process can be automized, but this is not part of the scope of this training.

Next, we should create a function that establishes our MQTT connection. For that we will use an **async** function, which enables us to write promise based code. Inside it, we can make use of the **await** operator, which lets our JavaScript code wait until the **connectAsync** call to MQTT returns a result.

```javascript
async createMqttConnection() {
  const decodedMqttToken = jwt.decode(token);
  const clientId = decodedMqttToken['client-id'];
  var authConfig = {
    clientId,
    username: clientId,
    password: token
  };

  const client = await mqtt.connectAsync("wss://mqtt.poc.kpn-dsh.com:8443/mqtt", authConfig);
  client.on("message", (topic, payload) => this.messageHandler(topic, payload));

  this.subscribeToTopic(client);
}
```

In our function, we first decode our token and get the client id from it. We create an **authConfig** object to connect to MQTT.

When our connection is established, we can attach an **event listener** to our client, which waits for a message to be received by MQTT. When a message comes in, a function is called that reads the received data.

We will create a separate **messageHandler** function in our component that handles the data:

```javascript
messageHandler(topic, payload) {
  const enc = new TextDecoder('utf-8');
  var decodedPayload = JSON.parse(enc.decode(payload));
  this.renderMarker(decodedPayload);
}
```

The payload needs to be decoded and parsed into JSON for easily reading it. Only then can the data be used for rendering a marker on the map.


### Subscribing to a topic

In our Tenant in One Day, we learned about what topics are. MQTT can be used for subscribing to different topics, in this example we will make use of a topic called airpollution. We will be receiving data from sensors that indicate the air pollution rating and readings from a certain location.

![](/dsh-perfecttenants.svg)

To subscribe to this topic, we start by adding a **subscribeToTopic** function:

```javascript
subscribeToTopic(client) {
  var topic = (airpollutionTopic);
  client.subscribe(topic);
}
```

The only thing needed to subscribe to a topic and start receiving data is to call **client.subscribe(topic).** The messages that we will start receiving will contain data, which after decoding will look something like this:

```
{
  lat: 52.378,
  location: "N/A-19652",
  long: 4.87,
  quadkey: "1/2/0/2/0/2/1/1/0/1/1/3/2/3/3/2",
  rating: 2,
  readings: "PM10: 12.5 μg/m3(1), PM2.5: 7.5 μg/m3(2), Humid: 99.9 %, Temp: 17.3 °C",
  station_id: "18463",
  timestamp_measured: "2020-06-03T07:24:34Z",
  type: "luftdaten"
}
```


### Adding markers to the map

After subscribing to a topic, we receive new data. Therefore, new markers need to be added on the map. From our air pollution topic, we get information about air pollution in a few different locations. We will be displaying those locations as dots on the map, with different color defined depending on the pollution rating. Leaflet also allows us to bind a pop-up to our marker that opens when you click on a dot. In there, some additional text information can be provided.

Let's create a **renderMarker** function that is responsible for creating this marker:

```javascript
renderMarker(data) {
  var fillColor

  switch (data.rating) {
    case 1: 
        fillColor = '#0048ff'
      break
    case 2: 
        fillColor = '#00a103'
        break
    case 3:  
        fillColor = '#ffdd00'
        break        
    case 4:           
        fillColor = '#ffae00'
        break            
    case 5:  
        fillColor = '#ff8000'
        break
      default:
        fillColor = '#ff8000'
        break
  }

  var icon = L.divIcon({
    className: "",
    iconSize: [15, 15],
    html: '<div class="marker" style="background-color: ' + fillColor + '"></div>'
  });

  const marker = L.marker([data.lat, data.long], {icon: icon});
  marker.bindPopup(`
    <div>Location:</span> <span>${data.location}</span> <br>
    <div>Reading: </span> <span>${data.readings}</span>
  `);

  marker.addTo(this.state.map);
}
```

In this function, as a first step we have a switch that will match the pollution rating from the data to a color, which we will use for our marker.

The second step will be to use Leaflet's **L.divIcon** function. This will create a div with a background-color, which is used as a marker on the map. We give our element a css class called **marker** , which we will use shortly for styling. By using **L.marker** we set the coordinates of our marker, taken from our MQTT message data and an icon.

Third, we can add a pop-up to our marker by using **marker.bindPopup**. This will add an element with additional text, which will be displayed when you click on the marker.

Finally, we use **marker.addTo(this.state.map)** to add our new marker on the map.

| function | description |
| --- | --- |
| L | Refers to Leaflet |
| L.divIcon | Creates a HTML div element, which is used as a marker |
| L.marker | Instantiates a Marker object given a geographical point and optionally a icon |
| marker.bindPopup | Binds a pop-up to the marker, which contains HTML elements |
| marker.addTo | Renders the marker on the map |

To make our markers look like colored circles on the map, we will need a few lines of css. Let&#39;s add those inside our Map.css:

```css
.marker {
  width: 20px;
  height: 20px;
  border-radius: 10px;
}
```


### Final result

To visualize the app that we just created, we will call our **createMqttConnection** function. We should do this after the map is rendered. This will make sure that when data comes in the markers are able to be added on the map. That is why we will call **createMqttConnection** inside our **renderMap** function. For that, we will slightly change our **setState** call from this

```javascript
this.setState({
      map
});
```

to this:

```javascript
this.setState({
  map
}, () => {
  this.createMqttConnection();
});
```

The result of this example will display something like this:

![](/react-demo.png)
